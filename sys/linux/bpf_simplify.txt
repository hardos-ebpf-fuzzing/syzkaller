# Copyright 2015 syzkaller project authors. All rights reserved.
# Use of this source code is governed by Apache 2 LICENSE that can be found in the LICENSE file.

include <uapi/linux/bpf.h>
include <uapi/linux/btf.h>
include <uapi/linux/if_link.h>

resource fd_bpf_task_storage[fd]: BPF_PSEUDO_MAP_FD

bpf$SIMP_MAP_CREATE(cmd const[BPF_MAP_CREATE], arg ptr[in, bpf_simp_map_create_arg], size len[arg]) fd_bpf_map
bpf$SIMP_TASK_STORAGE_CREATE(cmd const[BPF_MAP_CREATE], arg ptr[in, bpf_task_storage_create_arg], size len[arg]) fd_bpf_task_storage
bpf$SIMP_PROG_LOAD(cmd const[BPF_PROG_LOAD], arg ptr[in, bpf_simp_prog], size len[arg]) fd_bpf_prog
#bpf$BPF_SIMP_PROG_ATTACH(cmd const[BPF_PROG_ATTACH], arg ptr[in, bpf_attach_arg], size len[arg])
bpf$SIMP_BPF_RAW_TRACEPOINT_OPEN(cmd const[BPF_RAW_TRACEPOINT_OPEN], arg ptr[in, bpf_simp_raw_tracepoint], size len[arg]) fd_perf_base (timeout[500])
syz_mycall()
syz_bpf_attach_tp(prog fd_bpf_prog)

# ignore bloomfilter for now
# also ignore all the fancy fields after `flags`
bpf_simp_map_create_arg {
	type			flags[simp_bpf_map_type, int32]
	ksize			int32
	vsize			int32
	max			int32
	flags			flags[simp_map_flags, int32]
	inner			const[0, int32]
	node			const[0, int32]
	map_name		array[const[0, int8], BPF_OBJ_NAME_LEN]
	map_ifindex		const[0, int32]
	btf_fd			const[0, int32]
	btf_key_type_id		const[0, int32]
	btf_value_type_id	const[0, int32]
	btf_vmlinux_type_id	const[0, int32]
	map_extra		const[0, int64]
}

# ignore bloomfilter for now
# also ignore all the fancy fields after `flags`
bpf_task_storage_create_arg {
	type			const[BPF_MAP_TYPE_TASK_STORAGE, int32]
	ksize			const[4, int32]
	vsize			int32
	max			const[0, int32]
	flags			const[BPF_F_NO_PREALLOC, int32]
	inner			const[0, int32]
	node			const[0, int32]
	map_name		array[const[0, int8], BPF_OBJ_NAME_LEN]
	map_ifindex		const[0, int32]
	btf_fd			const[0, int32]
	btf_key_type_id		const[0, int32]
	btf_value_type_id	const[0, int32]
	btf_vmlinux_type_id	const[0, int32]
	map_extra		const[0, int64]
}

type bpf_simp_prog_t[TYPE, ATTACH_TYPE, BTF_ID, PROG_FD] {
	type			TYPE
	ninsn			bytesize8[insns, int32]
	insns			ptr64[in, bpf_simp_instructions]
	license			ptr64[in, string["GPL"]]
	loglev			const[0, int32]
	logsize			len[log, int32]
	log			ptr64[out, const[0, int32], opt]
	kern_version		flags[bpf_kern_version, int32]
	flags			flags[bpf_prog_load_flags, int32]
	prog_name		array[const[0, int8], BPF_OBJ_NAME_LEN]
	prog_ifindex		ifindex[opt]
	expected_attach_type	ATTACH_TYPE
	btf_fd			fd_btf[opt]
	func_info_rec_size	const[BPF_FUNC_INFO_SIZE, int32]
	func_info		ptr64[in, bpf_func_info]
	func_info_cnt		len[func_info, int32]
	line_info_rec_size	const[BPF_LINE_INFO_SIZE, int32]
	line_info		ptr64[in, bpf_line_info]
	line_info_cnt		const[0, int32]
	attach_btf_id		BTF_ID
	attach_prog_fd		PROG_FD
	pad			const[0, int32]
	fd_array		ptr64[in, array[fd_bpf_map], opt]
}

type bpf_simp_prog bpf_simp_prog_t[flags[bpf_simp_prog_type, int32], flags[bpf_simp_attach_type, int32], const[0, int32], const[0, int32]]

bpf_simp_prog_type = BPF_PROG_TYPE_RAW_TRACEPOINT
#bpf_simp_prog_type = BPF_PROG_TYPE_TRACEPOINT
bpf_simp_attach_type = BPF_TRACE_RAW_TP

bpf_simp_instructions [
	framed	bpf_simp_framed_program
] [varlen]

bpf_simp_framed_program {
	initr0	bpf_simp_insn_init_r0
	body	bpf_simp_insn
	exit	bpf_insn_exit
} [packed]

bpf_simp_insn_init_r0 {
	code	const[0xb7, int8]
	dst	const[BPF_REG_0, int8:4]
	src	const[0, int8:4]
	off	const[0, int16]
	imm	int32
}

bpf_simp_insn [
#call_hardos_test	bpf_hardos_test_insns
	call_map_lookup_elem	bpf_map_lookup_elem_insns
	call_map_update_elem	bpf_map_update_elem_insns
	call_map_delete_elem	bpf_map_delete_elem_insns
	call_map_push_elem	bpf_map_push_elem_insns
	call_map_pop_elem	bpf_map_pop_elem_insns
	call_map_peek_elem	bpf_map_peek_elem_insns
	call_task_storage_get	bpf_task_storage_get_insns
] [varlen]

#bpf_simp_attach_arg {
#        target_fd       bpf_attach_targets
#        attach_bpf_fd   fd_bpf_prog
#        type            flags[bpf_simp_attach_type, int32]
#        flags           flags[bpf_attach_flags, int32]
#        replace_bpf_fd  fd_bpf_prog
#}

bpf_simp_raw_tracepoint {
	name	ptr64[in, string[bpf_simp_raw_tracepoint_names]]
	prog_fd	fd_bpf_prog
} [align[8]]

bpf_simp_raw_tracepoint_names = "sys_enter"

# array and hash maps for simplicity
simp_bpf_map_type = BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_ARRAY
# 0 for now
simp_map_flags = 0

# BPF_ALU64 = 0x07
define bpf_mov_imm_code	0x07 | BPF_MOV | BPF_K

# dst_reg = imm
type bpf_mov_imm[ARGTYPE, REG] {
	code	const[0xb7, int8]
	dst	const[REG, int8:4]
	src	const[0, int8:4]
	off	const[0, int16]
	imm	ARGTYPE
}

# BPF_ALU64 = 0x07
define bpf_mov_reg_code	0x07 | BPF_MOV | BPF_X

type bpf_mov_reg[DST, SRC] {
	code	const[0xbf, int8]
	dst	const[DST, int8:4]
	src	const[SRC, int8:4]
	off	const[0, int16]
	imm	const[0, int32]
}

# BPF_ALU64 = 0x07
define bpf_add_imm_code	0x07 | BPF_ADD | BPF_K

type bpf_add_imm[DST, IMM] {
	code	const[0x7, int8]
	dst	const[DST, int8:4]
	src	const[0, int8:4]
	off	const[0, int16]
	imm	const[IMM, int32]
}

# dst_reg = imm64
# 64-bit load takes 2 instructions
# see https://elixir.bootlin.com/linux/latest/source/include/linux/filter.h#L190
# map fd are always 32-bit, a good news for us ;)
# no need to worry about the second instruciton at all
# see https://elixir.bootlin.com/linux/latest/source/include/uapi/linux/bpf.h#L1306
type bpf_helper_map_arg[MAPFD, REG] {
	code	const[0x18, int8]
	dst	const[REG, int8:4]
# magic src value needed by verifier for BPF_LD_MAP_FD
	src	const[1, int8:4]
	off	const[0, int16]
	imm	MAPFD
	unused	const[0, int64]
}

define bpf_call_code	BPF_JMP | BPF_CALL

type bpf_helper_call[HELPER_ID] {
	code	const[bpf_call_code, int8]
	regs	const[0, int8]
	off	const[0, int16]
	func	const[HELPER_ID, int32]
}

#bpf_hardos_test_insns {
#	mov_r1	bpf_mov_imm[int32, BPF_REG_1]
#	call	bpf_helper_call[204]
#} [packed]

# for allocating stack space
# BPF_DW = 0x18
define bpf_stxdw_code	BPF_STX | 0x18 | BPF_MEM

type bpf_stxdw[DST, SRC, OFF] {
	code	const[bpf_stxdw_code, int8]
	dst	const[DST, int8:4]
	src	const[SRC, int8:4]
	off	const[OFF, int16]
	imm	const[0, int32]
}

# BPF_CALL_2(bpf_map_lookup_elem, struct bpf_map *, map, void *, key)
# consider a simple case where we only use the same stack location as key
bpf_map_lookup_elem_insns {
	mov_keyval	bpf_mov_imm[int32, BPF_REG_1]
	st_keyval	bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	mov_r2_1	bpf_mov_reg[BPF_REG_2, BPF_REG_10]
	mov_r2_2	bpf_add_imm[BPF_REG_2, -8]
	mov_r1		bpf_helper_map_arg[fd_bpf_map, BPF_REG_1]
	call		bpf_helper_call[1]
} [packed]

# BPF_CALL_4(bpf_map_update_elem, struct bpf_map *, map, void *, key,
#           void *, value, u64, flags)
bpf_map_update_elem_insns {
	mov_keyval	bpf_mov_imm[int32, BPF_REG_1]
	st_keyval	bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	update_stx_1	bpf_add_imm[BPF_REG_10, -8]
	mov_r2_1	bpf_mov_reg[BPF_REG_2, BPF_REG_10]
	mov_val		bpf_mov_imm[int32, BPF_REG_1]
	st_val		bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	update_stx_2	bpf_add_imm[BPF_REG_10, -8]
	mov_r3_1	bpf_mov_reg[BPF_REG_3, BPF_REG_10]
	flag		bpf_mov_imm[flags[bpf_map_flags, int64], BPF_REG_4]
	mov_r1		bpf_helper_map_arg[fd_bpf_map, BPF_REG_1]
	call		bpf_helper_call[2]
} [packed]

# BPF_CALL_2(bpf_map_delete_elem, struct bpf_map *, map, void *, key)
bpf_map_delete_elem_insns {
	mov_keyval	bpf_mov_imm[int32, BPF_REG_1]
	st_keyval	bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	mov_r2_1	bpf_mov_reg[BPF_REG_2, BPF_REG_10]
	mov_r2_2	bpf_add_imm[BPF_REG_2, -8]
	mov_r1		bpf_helper_map_arg[fd_bpf_map, BPF_REG_1]
	call		bpf_helper_call[3]
} [packed]

# BPF_CALL_3(bpf_map_push_elem, struct bpf_map *, map, void *, value, u64, flags)
bpf_map_push_elem_insns {
	mov_val		bpf_mov_imm[int32, BPF_REG_1]
	st_keyval	bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	update_stx_1	bpf_add_imm[BPF_REG_10, -8]
	mov_r2_1	bpf_mov_reg[BPF_REG_2, BPF_REG_10]
	flag		bpf_mov_imm[flags[bpf_map_flags, int64], BPF_REG_3]
	mov_r1		bpf_helper_map_arg[fd_bpf_map, BPF_REG_1]
	call		bpf_helper_call[4]
} [packed]

# BPF_CALL_2(bpf_map_pop_elem, struct bpf_map *, map, void *, value)
bpf_map_pop_elem_insns {
	st_keyval	bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	update_stx_1	bpf_add_imm[BPF_REG_10, -8]
	mov_r2_1	bpf_mov_reg[BPF_REG_2, BPF_REG_10]
	mov_r1		bpf_helper_map_arg[fd_bpf_map, BPF_REG_1]
	call		bpf_helper_call[5]
} [packed]

# BPF_CALL_2(bpf_map_peek_elem, struct bpf_map *, map, void *, value)
bpf_map_peek_elem_insns {
	st_keyval	bpf_stxdw[BPF_REG_10, BPF_REG_1, -8]
	update_stx_1	bpf_add_imm[BPF_REG_10, -8]
	mov_r2_1	bpf_mov_reg[BPF_REG_2, BPF_REG_10]
	mov_r1		bpf_helper_map_arg[fd_bpf_map, BPF_REG_1]
	call		bpf_helper_call[6]
} [packed]

# struct task_struct *bpf_get_current_task_btf(void)
bpf_get_current_task_btf_insns {
	call	bpf_helper_call[158]
} [packed]

# void *bpf_task_storage_get(struct bpf_map *map, struct task_struct *task, void *value, u64 flags)
bpf_task_storage_get_insns {
	get_task	bpf_get_current_task_btf_insns
	mov_r4		bpf_mov_imm[flags[bpf_local_storage_flag_t, int32], BPF_REG_4]
	mov_r3		bpf_mov_imm[const[0, int32], BPF_REG_3]
	mov_r2		bpf_mov_reg[BPF_REG_2, BPF_REG_0]
	mov_r1		bpf_helper_map_arg[fd_bpf_task_storage, BPF_REG_1]
	call		bpf_helper_call[156]
} [packed]

bpf_local_storage_flag_t = BPF_LOCAL_STORAGE_GET_F_CREATE
